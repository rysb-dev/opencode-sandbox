#!/bin/bash
# =============================================================================
# OpenCode Sandbox Launcher
# =============================================================================
# Usage: opencode-sandbox [project-directory]
#
# Runs opencode in a Docker container with:
#   - Network restricted to whitelisted hosts only
#   - Filesystem restricted to specified directories only
#   - Tool calls require explicit permission
#
# Configuration: ~/.config/opencode-sandbox/config
# =============================================================================

set -e

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/opencode-sandbox"
CONFIG_FILE="$CONFIG_DIR/config"
IMAGE_NAME="opencode-sandbox"
CONTAINER_NAME="opencode-sandbox-session"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

log_info()    { echo -e "${BLUE}[sandbox]${NC} $1"; }
log_success() { echo -e "${GREEN}[sandbox]${NC} $1"; }
log_warn()    { echo -e "${YELLOW}[sandbox]${NC} $1"; }
log_error()   { echo -e "${RED}[sandbox]${NC} $1" >&2; }
log_header()  { echo -e "${BOLD}$1${NC}"; }

show_help() {
    cat << EOF
${BOLD}OpenCode Sandbox${NC} - Run opencode in a secure, isolated environment

${BOLD}USAGE:${NC}
    opencode-sandbox [OPTIONS] [PROJECT_DIR]
    opencode-sandbox shell    Open a bash shell in the running sandbox

${BOLD}ARGUMENTS:${NC}
    PROJECT_DIR    Directory to mount as workspace (default: current directory)

${BOLD}COMMANDS:${NC}
    shell          Open a bash shell in the running sandbox container

${BOLD}OPTIONS:${NC}
    -h, --help     Show this help message
    -u, --update   Update opencode to the latest version (rebuilds image)
    -c, --config   Open configuration file in editor
    --no-network   Disable all network access
    --skip-firewall Skip firewall setup (allows all network, for debugging)

${BOLD}CONFIGURATION:${NC}
    Edit: $CONFIG_FILE

${BOLD}EXAMPLES:${NC}
    opencode-sandbox                    # Run in current directory
    opencode-sandbox ~/Projects/myapp   # Run in specific directory
    opencode-sandbox shell              # Open shell in running sandbox
    opencode-sandbox --update           # Update opencode and rebuild image

EOF
}

# -----------------------------------------------------------------------------
# Parse configuration file
# -----------------------------------------------------------------------------
parse_config() {
    NETWORK_HOSTS=()
    FILESYSTEM_MOUNTS=()
    PROXY_HTTP=""
    PROXY_HTTPS=""
    PROXY_NO=""

    if [[ ! -f "$CONFIG_FILE" ]]; then
        log_warn "Config file not found: $CONFIG_FILE"
        log_info "Using default configuration"
        # Default hosts if no config
        NETWORK_HOSTS=("api.anthropic.com" "api.openai.com" "github.com")
        return
    fi

    local section=""
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        line=$(echo "$line" | xargs)  # trim whitespace

        # Check for section headers
        if [[ "$line" =~ ^\[.*\]$ ]]; then
            section=""
            [[ "$line" == *"network"* || "$line" == *"NETWORK"* ]] && section="network"
            [[ "$line" == *"filesystem"* || "$line" == *"FILESYSTEM"* ]] && section="filesystem"
            [[ "$line" == *"proxy"* || "$line" == *"PROXY"* ]] && section="proxy"
            continue
        fi

        case "$section" in
            network)    NETWORK_HOSTS+=("$line") ;;
            filesystem) FILESYSTEM_MOUNTS+=("$line") ;;
            proxy)
                # Parse key=value pairs for proxy settings
                if [[ "$line" =~ ^http_proxy[[:space:]]*= ]]; then
                    PROXY_HTTP="${line#*=}"
                    PROXY_HTTP=$(echo "$PROXY_HTTP" | xargs)  # trim whitespace
                elif [[ "$line" =~ ^https_proxy[[:space:]]*= ]]; then
                    PROXY_HTTPS="${line#*=}"
                    PROXY_HTTPS=$(echo "$PROXY_HTTPS" | xargs)
                elif [[ "$line" =~ ^no_proxy[[:space:]]*= ]]; then
                    PROXY_NO="${line#*=}"
                    PROXY_NO=$(echo "$PROXY_NO" | xargs)
                fi
                ;;
        esac
    done < "$CONFIG_FILE"
}

# -----------------------------------------------------------------------------
# Build or update Docker image
# -----------------------------------------------------------------------------
build_image() {
    local force_rebuild="${1:-false}"

    if [[ "$force_rebuild" == "true" ]] || ! docker image inspect "$IMAGE_NAME" &>/dev/null; then
        log_info "Building sandbox Docker image..."

        # Find the Dockerfile location
        local dockerfile_dir="$SCRIPT_DIR"
        if [[ ! -f "$dockerfile_dir/Dockerfile" ]]; then
            # Try config directory
            dockerfile_dir="$CONFIG_DIR"
        fi

        if [[ ! -f "$dockerfile_dir/Dockerfile" ]]; then
            log_error "Dockerfile not found in $SCRIPT_DIR or $CONFIG_DIR"
            exit 1
        fi

        docker build --no-cache -t "$IMAGE_NAME" "$dockerfile_dir"
        log_success "Image built successfully"
    fi
}

# -----------------------------------------------------------------------------
# Open shell in running sandbox
# -----------------------------------------------------------------------------
open_shell() {
    # Find running sandbox container
    local container_id
    container_id=$(docker ps -q -f "name=$CONTAINER_NAME" 2>/dev/null)

    if [[ -z "$container_id" ]]; then
        log_error "No running sandbox found."
        echo ""
        echo "Start a sandbox first with:"
        echo "  opencode-sandbox [project-directory]"
        echo ""
        echo "Then in another terminal, run:"
        echo "  opencode-sandbox shell"
        exit 1
    fi

    log_info "Attaching shell to running sandbox..."
    log_info "Type 'exit' to close this shell (sandbox will keep running)"
    echo ""

    # Attach an interactive bash shell as the coder user
    docker exec -it "$container_id" gosu coder bash
}

# -----------------------------------------------------------------------------
# Update opencode
# -----------------------------------------------------------------------------
update_opencode() {
    log_header "Updating OpenCode Sandbox"
    echo ""

    # Check if we're in a git repo with the source files
    local repo_dir=""
    if [[ -f "$SCRIPT_DIR/Dockerfile" && -f "$SCRIPT_DIR/entrypoint.sh" ]]; then
        repo_dir="$SCRIPT_DIR"
    fi

    # Try to update from git repo if available
    if [[ -n "$repo_dir" && -d "$repo_dir/.git" ]]; then
        log_info "Found git repository at $repo_dir"
        log_info "Pulling latest changes..."
        if (cd "$repo_dir" && git pull --ff-only 2>/dev/null); then
            log_success "Repository updated"
        else
            log_warn "Could not pull updates (you may have local changes)"
        fi

        # Update installed files from repo
        log_info "Updating installed files..."
        cp "$repo_dir/opencode-sandbox" "$CONFIG_DIR/../../../.local/bin/opencode-sandbox" 2>/dev/null || \
            cp "$repo_dir/opencode-sandbox" "$HOME/.local/bin/opencode-sandbox" 2>/dev/null || true
        cp "$repo_dir/Dockerfile" "$CONFIG_DIR/" 2>/dev/null || true
        cp "$repo_dir/entrypoint.sh" "$CONFIG_DIR/" 2>/dev/null || true
        cp "$repo_dir/opencode.json" "$CONFIG_DIR/" 2>/dev/null || true
        log_success "Installed files updated"
    elif [[ -n "$repo_dir" ]]; then
        # Source files exist but not a git repo - just copy them
        log_info "Updating installed files from $repo_dir..."
        cp "$repo_dir/opencode-sandbox" "$HOME/.local/bin/opencode-sandbox" 2>/dev/null || true
        cp "$repo_dir/Dockerfile" "$CONFIG_DIR/" 2>/dev/null || true
        cp "$repo_dir/entrypoint.sh" "$CONFIG_DIR/" 2>/dev/null || true
        cp "$repo_dir/opencode.json" "$CONFIG_DIR/" 2>/dev/null || true
        log_success "Installed files updated"
    else
        log_info "No source repository found - only rebuilding Docker image"
        log_info "To update scripts, run: cd /path/to/opencode-sandbox && git pull && ./setup.sh"
    fi

    echo ""
    log_info "Rebuilding Docker image with latest opencode..."
    build_image true
    echo ""
    log_success "Update complete!"

    # Show new version
    local version=$(docker run --rm "$IMAGE_NAME" opencode --version 2>/dev/null || echo "unknown")
    log_info "OpenCode version: $version"
}

# -----------------------------------------------------------------------------
# Main run function
# -----------------------------------------------------------------------------
run_sandbox() {
    local project_dir="${1:-$(pwd)}"
    local skip_firewall="${SKIP_FIREWALL:-false}"
    local no_network="${NO_NETWORK:-false}"

    # Resolve to absolute path
    project_dir=$(cd "$project_dir" 2>/dev/null && pwd) || {
        log_error "Directory not found: $project_dir"
        exit 1
    }

    log_header "OpenCode Sandbox"
    echo ""
    log_info "Project: $project_dir"

    # Parse config
    parse_config

    # Build hosts list
    local hosts_csv=""
    if [[ "$no_network" == "true" ]]; then
        log_warn "Network access: DISABLED"
        hosts_csv=""
    elif [[ ${#NETWORK_HOSTS[@]} -gt 0 ]]; then
        echo ""
        log_info "Network whitelist:"
        for host in "${NETWORK_HOSTS[@]}"; do
            log_info "  ✓ $host"
            [[ -n "$hosts_csv" ]] && hosts_csv+=","
            hosts_csv+="$host"
        done
    fi

    # Build volume mounts
    local -a volume_args=()

    # Project directory (always read-write)
    volume_args+=("-v" "$project_dir:/workspace:rw")

    # OpenCode config/cache directories (persistent across runs)
    local opencode_config="$HOME/.config/opencode"
    local opencode_cache="$HOME/.cache/opencode"
    local opencode_data="$HOME/.local/share/opencode"
    local opencode_state="$HOME/.local/state/opencode"

    mkdir -p "$opencode_cache" "$opencode_data" "$opencode_state"

    # Only mount opencode config if user has a valid config.json
    # Otherwise, use the container's built-in default (requires permission for all tools)
    if [[ -f "$opencode_config/config.json" ]]; then
        volume_args+=("-v" "$opencode_config:/home/coder/.config/opencode:rw")
        log_info "Using host opencode config: $opencode_config/config.json"
    else
        log_info "No host config.json found - using container default (tool calls require permission)"
    fi

    volume_args+=("-v" "$opencode_cache:/home/coder/.cache/opencode:rw")
    volume_args+=("-v" "$opencode_data:/home/coder/.local/share/opencode:rw")
    volume_args+=("-v" "$opencode_state:/home/coder/.local/state/opencode:rw")

    # Git config (read-only)
    [[ -f "$HOME/.gitconfig" ]] && volume_args+=("-v" "$HOME/.gitconfig:/home/coder/.gitconfig:ro")
    [[ -d "$HOME/.config/git" ]] && volume_args+=("-v" "$HOME/.config/git:/home/coder/.config/git:ro")

    # SSH config and keys (read-only) - enables git push/pull via SSH
    if [[ -d "$HOME/.ssh" ]]; then
        volume_args+=("-v" "$HOME/.ssh:/home/coder/.ssh:ro")
        log_info "  ✓ ~/.ssh (read-only, for git SSH access)"
    fi

    echo ""
    log_info "Filesystem access:"
    log_info "  ✓ $project_dir (read-write)"

    # Additional filesystem mounts from config
    for mount in "${FILESYSTEM_MOUNTS[@]}"; do
        local host_path="${mount%%:*}"
        local mode="ro"
        [[ "$mount" == *":rw" ]] && mode="rw"
        host_path="${host_path%:rw}"

        if [[ -d "$host_path" ]]; then
            local container_path="/mnt$(echo "$host_path" | tr ' ' '_')"
            volume_args+=("-v" "$host_path:$container_path:$mode")
            log_info "  ✓ $host_path ($mode)"
        else
            log_warn "  ✗ $host_path (not found, skipping)"
        fi
    done

    # Ensure image exists
    build_image

    echo ""
    log_success "Starting sandboxed opencode..."
    log_info "Press Ctrl+C to exit"
    echo ""

    # Environment variables
    local -a env_args=()
    env_args+=("-e" "ALLOWED_HOSTS=$hosts_csv")
    env_args+=("-e" "TERM=$TERM")
    [[ "$skip_firewall" == "true" ]] && env_args+=("-e" "SKIP_FIREWALL=true")

    # SSH agent forwarding - allows git operations without exposing private keys
    if [[ -n "$SSH_AUTH_SOCK" ]]; then
        # Check if Docker Desktop's magic socket exists (macOS/Windows Docker Desktop)
        if [[ -S "/run/host-services/ssh-auth.sock" ]]; then
            volume_args+=("-v" "/run/host-services/ssh-auth.sock:/ssh-agent")
            env_args+=("-e" "SSH_AUTH_SOCK=/ssh-agent")
            log_info "SSH agent: forwarded (Docker Desktop)"
        elif [[ "$OSTYPE" == "linux-gnu"* ]] && [[ -S "$SSH_AUTH_SOCK" ]]; then
            # On Linux, socket forwarding works natively (no VM in between)
            volume_args+=("-v" "$SSH_AUTH_SOCK:/ssh-agent")
            env_args+=("-e" "SSH_AUTH_SOCK=/ssh-agent")
            log_info "SSH agent: forwarded (Linux)"
        else
            # For macOS with Colima/Lima, Unix socket forwarding doesn't work
            # because sockets can't pass through the Linux VM.
            # The mounted ~/.ssh directory with keys will be used instead.
            log_info "SSH agent: using mounted ~/.ssh keys (socket forwarding unavailable)"
        fi
    else
        log_info "SSH: using mounted ~/.ssh keys"
    fi

    # Proxy configuration (if set)
    if [[ -n "$PROXY_HTTP" || -n "$PROXY_HTTPS" ]]; then
        echo ""
        log_info "Proxy configuration:"
        if [[ -n "$PROXY_HTTP" ]]; then
            env_args+=("-e" "http_proxy=$PROXY_HTTP")
            env_args+=("-e" "HTTP_PROXY=$PROXY_HTTP")
            log_info "  ✓ http_proxy=$PROXY_HTTP"
        fi
        if [[ -n "$PROXY_HTTPS" ]]; then
            env_args+=("-e" "https_proxy=$PROXY_HTTPS")
            env_args+=("-e" "HTTPS_PROXY=$PROXY_HTTPS")
            log_info "  ✓ https_proxy=$PROXY_HTTPS"
        fi
        if [[ -n "$PROXY_NO" ]]; then
            env_args+=("-e" "no_proxy=$PROXY_NO")
            env_args+=("-e" "NO_PROXY=$PROXY_NO")
            log_info "  ✓ no_proxy=$PROXY_NO"
        fi
        echo ""
    fi

    # Run container with a name so we can attach to it later
    docker run --rm -it \
        --name "$CONTAINER_NAME" \
        --cap-add=NET_ADMIN \
        "${env_args[@]}" \
        "${volume_args[@]}" \
        "$IMAGE_NAME" \
        opencode
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------
main() {
    # Check Docker
    if ! command -v docker &>/dev/null; then
        log_error "Docker not found. Please install Docker Desktop."
        exit 1
    fi

    if ! docker info &>/dev/null 2>&1; then
        log_error "Docker daemon not running. Please start Docker Desktop."
        exit 1
    fi

    # Parse arguments
    local project_dir=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -u|--update)
                update_opencode
                exit 0
                ;;
            -c|--config)
                ${EDITOR:-vim} "$CONFIG_FILE"
                exit 0
                ;;
            shell)
                open_shell
                exit 0
                ;;
            --no-network)
                export NO_NETWORK=true
                shift
                ;;
            --skip-firewall)
                export SKIP_FIREWALL=true
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
            *)
                project_dir="$1"
                shift
                ;;
        esac
    done

    run_sandbox "$project_dir"
}

main "$@"
