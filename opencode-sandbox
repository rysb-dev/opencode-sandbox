#!/bin/bash
# =============================================================================
# OpenCode Sandbox Launcher
# =============================================================================
# Usage: opencode-sandbox [project-directory]
#
# Runs opencode in a Docker container with:
#   - Network restricted to whitelisted domains via squid proxy
#   - Filesystem restricted to specified directories only
#   - Tool calls require explicit permission
#
# Configuration: ~/.config/opencode-sandbox/config
# =============================================================================

set -e

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/opencode-sandbox"
CONFIG_FILE="$CONFIG_DIR/config"
COMPOSE_PROJECT="opencode-sandbox"
PROXY_CONTAINER="opencode-sandbox-proxy"
AGENT_CONTAINER="opencode-sandbox-agent"

# ACP mode constants (separate compose project to allow coexistence with TUI)
COMPOSE_PROJECT_ACP="opencode-sandbox-acp"
PROXY_CONTAINER_ACP="opencode-sandbox-acp-proxy"
AGENT_CONTAINER_ACP="opencode-sandbox-acp-agent"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

log_info()    { echo -e "${BLUE}[sandbox]${NC} $1"; }
log_success() { echo -e "${GREEN}[sandbox]${NC} $1"; }
log_warn()    { echo -e "${YELLOW}[sandbox]${NC} $1"; }
log_error()   { echo -e "${RED}[sandbox]${NC} $1" >&2; }
log_header()  { echo -e "${BOLD}$1${NC}"; }

show_help() {
    echo -e "${BOLD}OpenCode Sandbox${NC} - Run opencode in a secure, network-isolated environment"
    echo ""
    echo -e "${BOLD}USAGE:${NC}"
    echo "    opencode-sandbox [OPTIONS] [PROJECT_DIR]"
    echo "    opencode-sandbox acp [PROJECT_DIR]   Run in ACP mode for editor integration"
    echo "    opencode-sandbox shell               Open a bash shell in the running sandbox"
    echo ""
    echo -e "${BOLD}ARGUMENTS:${NC}"
    echo "    PROJECT_DIR    Directory to mount as workspace (default: current directory)"
    echo ""
    echo -e "${BOLD}COMMANDS:${NC}"
    echo "    acp            Run in ACP mode (Agent Client Protocol over stdin/stdout)"
    echo "    build          Force rebuild Docker images (without starting anything)"
    echo "    shell          Open a bash shell in the running sandbox container"
    echo "    shell --acp    Open a bash shell in the running ACP sandbox container"
    echo "    stop           Stop all sandbox containers"
    echo "    update         Update opencode to the latest version (rebuilds image)"
    echo ""
    echo -e "${BOLD}OPTIONS:${NC}"
    echo "    -h, --help     Show this help message"
    echo "    -b, --build    Force rebuild of Docker images"
    echo "    -u, --update   Update opencode to latest version (same as 'update')"
    echo "    -c, --config   Open configuration file in editor"
    echo "    --no-network   Disable all network access"
    echo "    --with-ssh     Mount ~/.ssh keys into container (disabled by default)"
    echo ""
    echo -e "${BOLD}CONFIGURATION:${NC}"
    echo "    Edit: $CONFIG_FILE"
    echo ""
    echo "    Network whitelist: Add domains (one per line) under [network]"
    echo "    Filesystem mounts: Add paths under [filesystem]"
    echo ""
    echo -e "${BOLD}EXAMPLES:${NC}"
    echo "    opencode-sandbox                    # Run in current directory"
    echo "    opencode-sandbox ~/Projects/myapp   # Run in specific directory"
    echo "    opencode-sandbox acp                # ACP mode for editor integration"
    echo "    opencode-sandbox build              # Rebuild images only"
    echo "    opencode-sandbox shell              # Open shell in running sandbox"
    echo "    opencode-sandbox shell --acp       # Open shell in running ACP sandbox"
    echo "    opencode-sandbox stop               # Stop all sandbox containers"
    echo "    opencode-sandbox update             # Update opencode to latest"
    echo "    opencode-sandbox --build            # Rebuild images and run"
    echo ""
    echo -e "${BOLD}ZED EDITOR INTEGRATION:${NC}"
    echo "    Add to ~/.config/zed/settings.json:"
    echo '    {'
    echo '      "agent_servers": {'
    echo '        "OpenCode (Sandboxed)": {'
    echo '          "type": "custom",'
    echo '          "command": "opencode-sandbox",'
    echo '          "args": ["acp"],'
    echo '          "env": {}'
    echo '        }'
    echo '      }'
    echo '    }'
    echo ""
}

# -----------------------------------------------------------------------------
# Ensure config directory and files exist
# -----------------------------------------------------------------------------
ensure_config() {
    if [[ ! -d "$CONFIG_DIR" ]]; then
        log_info "Creating configuration directory: $CONFIG_DIR"
        mkdir -p "$CONFIG_DIR"
    fi

    if [[ ! -f "$CONFIG_FILE" ]]; then
        log_info "Creating default configuration file"
        cat > "$CONFIG_FILE" << 'CONFIGEOF'
# =============================================================================
# OpenCode Sandbox Configuration
# =============================================================================
# Network whitelist: Domains opencode can connect to (one per line)
# Filesystem mounts: Additional directories to mount (one per line)
# =============================================================================

[network]
# LLM API providers (leading dot matches subdomains)
.anthropic.com
.openai.com

# GitHub - narrowed to specific subdomains for git operations
github.com
api.github.com
codeload.github.com
raw.githubusercontent.com
objects.githubusercontent.com

# GitHub Copilot
copilot-proxy.githubusercontent.com
origin-tracker.githubusercontent.com
.githubcopilot.com

# GitLab (uncomment if needed)
# gitlab.com
# .gitlab.com

# Python / pip / PyPI
pypi.org
files.pythonhosted.org

# Rust / Cargo / crates.io
crates.io
static.crates.io
index.crates.io

# Add additional domains below (use leading dot for subdomains):
# .example.com      - matches example.com and *.example.com
# api.example.com   - matches only api.example.com


[proxy]
# Corporate/upstream proxy configuration (optional)
# If your network requires a proxy to reach the internet, configure it here.
# The sandbox's squid proxy will route traffic through your corporate proxy.
#
# http_proxy=http://proxy.company.com:8080
# https_proxy=http://proxy.company.com:8080
# no_proxy=localhost,127.0.0.1,.internal.company.com,intranet.local
#
# Note: no_proxy domains will be accessed directly, bypassing the upstream proxy.
# This is useful for internal/intranet hosts that don't need the corporate proxy.


[filesystem]
# Additional directories to mount (read-only by default)
# Format:
#   /path/to/directory        - mounted read-only
#   /path/to/directory:rw     - mounted read-write
#
# Example:
#   /Users/yourname/shared-libs
#   /Users/yourname/other-project:rw


[environment]
# Additional environment variables for the agent container
# Format: KEY=value
#
# Example:
#   NODE_EXTRA_CA_CERTS=/mnt/certs/mycerts.pem

CONFIGEOF
    fi
}

# -----------------------------------------------------------------------------
# Parse configuration file
# -----------------------------------------------------------------------------
parse_config() {
    NETWORK_HOSTS=()
    FILESYSTEM_MOUNTS=()
    AGENT_ENV_VARS=()
    UPSTREAM_PROXY_HOST=""
    UPSTREAM_PROXY_PORT=""
    NO_PROXY_DOMAINS=""

    if [[ ! -f "$CONFIG_FILE" ]]; then
        log_warn "Config file not found: $CONFIG_FILE"
        return
    fi

    local section=""
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        line=$(echo "$line" | xargs)  # trim whitespace

        # Check for section headers
        if [[ "$line" =~ ^\[.*\]$ ]]; then
            section=""
            [[ "$line" == *"network"* || "$line" == *"NETWORK"* ]] && section="network"
            [[ "$line" == *"filesystem"* || "$line" == *"FILESYSTEM"* ]] && section="filesystem"
            [[ "$line" == *"proxy"* || "$line" == *"PROXY"* ]] && section="proxy"
            [[ "$line" == *"environment"* || "$line" == *"ENVIRONMENT"* ]] && section="environment"
            continue
        fi

        case "$section" in
            network)    NETWORK_HOSTS+=("$line") ;;
            filesystem) FILESYSTEM_MOUNTS+=("$line") ;;
            environment)
                # Parse KEY=value pairs for environment variables
                if [[ "$line" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
                    AGENT_ENV_VARS+=("$line")
                fi
                ;;
            proxy)
                # Parse key=value pairs for proxy settings
                if [[ "$line" =~ ^http_proxy[[:space:]]*= ]]; then
                    local proxy_url="${line#*=}"
                    proxy_url=$(echo "$proxy_url" | xargs)  # trim whitespace
                    # Parse host:port from URL (http://host:port or host:port)
                    proxy_url="${proxy_url#http://}"
                    proxy_url="${proxy_url#https://}"
                    UPSTREAM_PROXY_HOST="${proxy_url%%:*}"
                    UPSTREAM_PROXY_PORT="${proxy_url##*:}"
                    # If no port specified, default to 3128
                    [[ "$UPSTREAM_PROXY_HOST" == "$UPSTREAM_PROXY_PORT" ]] && UPSTREAM_PROXY_PORT="3128"
                elif [[ "$line" =~ ^https_proxy[[:space:]]*= ]]; then
                    # Only use https_proxy if http_proxy not already set
                    if [[ -z "$UPSTREAM_PROXY_HOST" ]]; then
                        local proxy_url="${line#*=}"
                        proxy_url=$(echo "$proxy_url" | xargs)
                        proxy_url="${proxy_url#http://}"
                        proxy_url="${proxy_url#https://}"
                        UPSTREAM_PROXY_HOST="${proxy_url%%:*}"
                        UPSTREAM_PROXY_PORT="${proxy_url##*:}"
                        [[ "$UPSTREAM_PROXY_HOST" == "$UPSTREAM_PROXY_PORT" ]] && UPSTREAM_PROXY_PORT="3128"
                    fi
                elif [[ "$line" =~ ^no_proxy[[:space:]]*= ]]; then
                    NO_PROXY_DOMAINS="${line#*=}"
                    NO_PROXY_DOMAINS=$(echo "$NO_PROXY_DOMAINS" | xargs)
                fi
                ;;
        esac
    done < "$CONFIG_FILE"
}

# -----------------------------------------------------------------------------
# Generate allowed_domains.txt for squid proxy
# -----------------------------------------------------------------------------
generate_allowed_domains() {
    local domains_file="$CONFIG_DIR/allowed_domains.txt"

    cat > "$domains_file" << 'EOF'
# Auto-generated from config - do not edit directly
# Edit ~/.config/opencode-sandbox/config instead
EOF

    for host in "${NETWORK_HOSTS[@]}"; do
        echo "$host" >> "$domains_file"
    done

    echo "$domains_file"
}

# -----------------------------------------------------------------------------
# Generate docker-compose.yml
# -----------------------------------------------------------------------------
generate_compose_file() {
    local project_dir="$1"
    local domains_file="$2"
    local mode="${3:-tui}"  # "tui" (default) or "acp"

    local compose_file
    local cur_proxy_container
    local cur_agent_container
    if [[ "$mode" == "acp" ]]; then
        compose_file="$CONFIG_DIR/docker-compose-acp.yml"
        cur_proxy_container="$PROXY_CONTAINER_ACP"
        cur_agent_container="$AGENT_CONTAINER_ACP"
    else
        compose_file="$CONFIG_DIR/docker-compose.yml"
        cur_proxy_container="$PROXY_CONTAINER"
        cur_agent_container="$AGENT_CONTAINER"
    fi

    # Get host UID/GID for proper file permission mapping
    local host_uid=$(id -u)
    local host_gid=$(id -g)

    # Build volume mounts for agent
    local volume_mounts=""
    volume_mounts+="      - ${project_dir}:/workspace:rw"$'\n'

    # OpenCode config directories
    local opencode_config="$HOME/.config/opencode"
    local opencode_cache="$HOME/.cache/opencode"
    local opencode_data="$HOME/.local/share/opencode"
    local opencode_state="$HOME/.local/state/opencode"

    # Create directories if they don't exist
    mkdir -p "$opencode_cache" "$opencode_data" "$opencode_state"

    # Mount opencode directories
    if [[ -d "$opencode_config" ]]; then
        volume_mounts+="      - ${opencode_config}:/home/coder/.config/opencode:rw"$'\n'
    fi
    volume_mounts+="      - ${opencode_cache}:/home/coder/.cache/opencode:rw"$'\n'
    volume_mounts+="      - ${opencode_data}:/home/coder/.local/share/opencode:rw"$'\n'
    volume_mounts+="      - ${opencode_state}:/home/coder/.local/state/opencode:rw"$'\n'

    # Git config (read-write so git can add safe.directory)
    [[ -f "$HOME/.gitconfig" ]] && volume_mounts+="      - ${HOME}/.gitconfig:/home/coder/.gitconfig:rw"$'\n'
    [[ -d "$HOME/.config/git" ]] && volume_mounts+="      - ${HOME}/.config/git:/home/coder/.config/git:ro"$'\n'

    # SSH keys (only mounted if --with-ssh is passed)
    if [[ -d "$HOME/.ssh" ]] && [[ "${WITH_SSH:-false}" == "true" ]]; then
        volume_mounts+="      - ${HOME}/.ssh:/mnt/ssh:ro"$'\n'
    fi

    # Additional filesystem mounts from config
    for mount in "${FILESYSTEM_MOUNTS[@]}"; do
        local host_path="${mount%%:*}"
        local mode="ro"
        [[ "$mount" == *":rw" ]] && mode="rw"
        host_path="${host_path%:rw}"

        if [[ -d "$host_path" ]]; then
            local container_path="/mnt$(echo "$host_path" | tr ' ' '_')"
            volume_mounts+="      - ${host_path}:${container_path}:${mode}"$'\n'
        fi
    done

    # Build proxy environment variables for upstream proxy
    local proxy_env=""
    if [[ -n "$UPSTREAM_PROXY_HOST" ]]; then
        proxy_env+="    environment:"$'\n'
        proxy_env+="      - UPSTREAM_PROXY_HOST=${UPSTREAM_PROXY_HOST}"$'\n'
        proxy_env+="      - UPSTREAM_PROXY_PORT=${UPSTREAM_PROXY_PORT:-3128}"$'\n'
        if [[ -n "$NO_PROXY_DOMAINS" ]]; then
            proxy_env+="      - NO_PROXY_DOMAINS=${NO_PROXY_DOMAINS}"$'\n'
        fi
    fi

    # Mode-specific agent settings
    local agent_tty_settings=""
    local agent_command=""
    if [[ "$mode" == "acp" ]]; then
        # ACP mode: no TTY (would corrupt JSON-RPC), keep-alive so docker exec controls lifecycle
        agent_tty_settings="    stdin_open: false
    tty: false
    command: [\"tail\", \"-f\", \"/dev/null\"]"
    else
        # TUI mode: interactive terminal
        agent_tty_settings="    stdin_open: true
    tty: true"
    fi

    cat > "$compose_file" << EOF
# Auto-generated - do not edit directly
services:
  proxy:
    image: opencode-sandbox-proxy
    build:
      context: ${SCRIPT_DIR}/proxy
    container_name: ${cur_proxy_container}
    networks:
      - external
      - internal
    volumes:
      - ${domains_file}:/etc/squid/allowed_domains.txt:ro
${proxy_env}    healthcheck:
      test: ["CMD-SHELL", "nc -z localhost 3128 || exit 1"]
      interval: 3s
      timeout: 2s
      retries: 5
      start_period: 2s

  agent:
    image: opencode-sandbox-agent
    build:
      context: ${SCRIPT_DIR}/agent
      args:
        - USER_UID=${host_uid}
        - USER_GID=${host_gid}
    container_name: ${cur_agent_container}
${agent_tty_settings}
    networks:
      - internal
    depends_on:
      proxy:
        condition: service_healthy
    environment:
      - HTTP_PROXY=http://proxy:3128
      - HTTPS_PROXY=http://proxy:3128
      - http_proxy=http://proxy:3128
      - https_proxy=http://proxy:3128
      - NO_PROXY=localhost,127.0.0.1
      - no_proxy=localhost,127.0.0.1
      - TERM=${TERM:-xterm-256color}
$(for env_var in "${AGENT_ENV_VARS[@]}"; do echo "      - ${env_var}"; done)
    volumes:
${volume_mounts}    working_dir: /workspace

networks:
  external:
    driver: bridge
  internal:
    driver: bridge
    internal: true
EOF

    echo "$compose_file"
}

# -----------------------------------------------------------------------------
# Build Docker images
# -----------------------------------------------------------------------------
build_images() {
    local force="${1:-false}"
    local compose_file="$2"
    local no_cache="${3:-false}"
    local project="${4:-$COMPOSE_PROJECT}"

    # Check if images exist
    local need_build=false
    if [[ "$force" == "true" ]]; then
        need_build=true
    elif ! docker image inspect "opencode-sandbox-proxy" &>/dev/null || \
         ! docker image inspect "opencode-sandbox-agent" &>/dev/null; then
        need_build=true
    fi

    if [[ "$need_build" == "true" ]]; then
        log_info "Building Docker images..."
        if [[ "$no_cache" == "true" ]]; then
            docker compose -f "$compose_file" -p "$project" build --no-cache --quiet
        else
            docker compose -f "$compose_file" -p "$project" build --quiet
        fi
        log_success "Images built successfully"
    fi
}

# -----------------------------------------------------------------------------
# Update opencode (rebuild with no cache)
# -----------------------------------------------------------------------------
update_opencode() {
    log_header "Updating OpenCode"
    echo ""

    # Ensure config exists
    ensure_config

    # Parse config
    parse_config

    # Generate config files
    local domains_file
    domains_file=$(generate_allowed_domains)

    local compose_file
    compose_file=$(generate_compose_file "$(pwd)" "$domains_file")

    log_info "Rebuilding agent image with latest opencode..."
    docker compose -f "$compose_file" -p "$COMPOSE_PROJECT" build --no-cache agent

    echo ""
    log_success "Update complete!"

    # Show new version
    local version
    version=$(docker run --rm "${COMPOSE_PROJECT}-agent" opencode --version 2>/dev/null || echo "unknown")
    log_info "OpenCode version: $version"
}

# -----------------------------------------------------------------------------
# Start sandbox containers
# -----------------------------------------------------------------------------
start_sandbox() {
    local compose_file="$1"

    log_info "Starting sandbox containers..."
    docker compose -f "$compose_file" -p "$COMPOSE_PROJECT" up -d --quiet-pull 2>/dev/null

    # Wait for agent to be ready
    local retries=0
    while ! docker ps -q -f "name=${AGENT_CONTAINER}" -f "status=running" &>/dev/null && [[ $retries -lt 30 ]]; do
        sleep 0.5
        ((retries++))
    done

    if ! docker ps -q -f "name=${AGENT_CONTAINER}" -f "status=running" &>/dev/null; then
        log_error "Agent container failed to start"
        docker compose -f "$compose_file" -p "$COMPOSE_PROJECT" logs
        exit 1
    fi
}

# -----------------------------------------------------------------------------
# Stop sandbox containers
# -----------------------------------------------------------------------------
stop_sandbox() {
    local compose_file="$CONFIG_DIR/docker-compose.yml"

    if [[ -f "$compose_file" ]]; then
        log_info "Stopping sandbox containers..."
        docker compose -f "$compose_file" -p "$COMPOSE_PROJECT" down --remove-orphans 2>/dev/null || true
    else
        # Fallback: stop by container name
        docker stop "$AGENT_CONTAINER" "$PROXY_CONTAINER" 2>/dev/null || true
        docker rm "$AGENT_CONTAINER" "$PROXY_CONTAINER" 2>/dev/null || true
    fi
    log_success "Sandbox stopped"
}

# -----------------------------------------------------------------------------
# Attach to running sandbox
# -----------------------------------------------------------------------------
attach_shell() {
    local container="$AGENT_CONTAINER"
    local mode="sandbox"

    if [[ "$1" == "--acp" ]]; then
        container="$AGENT_CONTAINER_ACP"
        mode="ACP sandbox"
    fi

    if ! docker ps -q -f "name=${container}" -f "status=running" &>/dev/null; then
        log_error "No running ${mode} found."
        echo ""
        if [[ "$mode" == "ACP sandbox" ]]; then
            echo "Start an ACP sandbox first with:"
            echo "  opencode-sandbox acp [project-directory]"
        else
            echo "Start a sandbox first with:"
            echo "  opencode-sandbox [project-directory]"
        fi
        exit 1
    fi

    log_info "Attaching shell to running ${mode}..."
    log_info "Type 'exit' to close this shell (${mode} will keep running)"
    echo ""

    docker exec -it "$container" bash
}

# -----------------------------------------------------------------------------
# Cleanup on exit
# -----------------------------------------------------------------------------
cleanup() {
    echo ""
    log_info "Shutting down sandbox..."
    stop_sandbox
}

# -----------------------------------------------------------------------------
# Stop ACP sandbox containers
# -----------------------------------------------------------------------------
stop_sandbox_acp() {
    local compose_file="$CONFIG_DIR/docker-compose-acp.yml"

    if [[ -f "$compose_file" ]]; then
        log_info "Stopping ACP sandbox containers..." >&2
        docker compose -f "$compose_file" -p "$COMPOSE_PROJECT_ACP" down --remove-orphans 2>/dev/null || true
    else
        docker stop "$AGENT_CONTAINER_ACP" "$PROXY_CONTAINER_ACP" 2>/dev/null || true
        docker rm "$AGENT_CONTAINER_ACP" "$PROXY_CONTAINER_ACP" 2>/dev/null || true
    fi
    log_success "ACP sandbox stopped" >&2
}

# -----------------------------------------------------------------------------
# Cleanup ACP containers on exit
# -----------------------------------------------------------------------------
DOCKER_EXEC_PID=""
WATCHDOG_SCRIPT=""
cleanup_acp() {
    # Kill the watchdog script (not needed during normal cleanup)
    if [[ -n "$WATCHDOG_SCRIPT" ]]; then
        # Find and kill the watchdog process by script path
        pkill -f "$WATCHDOG_SCRIPT" 2>/dev/null
        rm -f "$WATCHDOG_SCRIPT"
    fi
    # Kill the docker exec process if still running
    if [[ -n "$DOCKER_EXEC_PID" ]] && kill -0 "$DOCKER_EXEC_PID" 2>/dev/null; then
        kill "$DOCKER_EXEC_PID" 2>/dev/null
        wait "$DOCKER_EXEC_PID" 2>/dev/null
    fi
    log_info "Shutting down ACP sandbox..." >&2
    stop_sandbox_acp
}

# -----------------------------------------------------------------------------
# Run sandbox in ACP mode (stdin/stdout JSON-RPC bridge for Zed/editors)
# -----------------------------------------------------------------------------
run_sandbox_acp() {
    local project_dir="${1:-$(pwd)}"
    local force_build="${FORCE_BUILD:-false}"
    local no_network="${NO_NETWORK:-false}"

    # Resolve to absolute path
    project_dir=$(cd "$project_dir" 2>/dev/null && pwd) || {
        log_error "Directory not found: $project_dir"
        exit 1
    }

    # All informational output goes to stderr — stdout is reserved for JSON-RPC
    log_info "ACP mode: bridging editor to sandboxed OpenCode" >&2
    log_info "Project: $project_dir" >&2

    # Ensure config exists
    ensure_config

    # Parse config
    parse_config

    # Handle no-network mode
    if [[ "$no_network" == "true" ]]; then
        log_warn "Network access: DISABLED" >&2
        NETWORK_HOSTS=()
    fi

    # Generate config files
    local domains_file
    domains_file=$(generate_allowed_domains)

    local compose_file
    compose_file=$(generate_compose_file "$project_dir" "$domains_file" "acp")

    # Build images if needed
    # Redirect stdout to stderr so build output doesn't corrupt JSON-RPC stream
    build_images "$force_build" "$compose_file" "false" "$COMPOSE_PROJECT_ACP" 1>&2

    # Stop any existing ACP sandbox
    if docker ps -q -f "name=${AGENT_CONTAINER_ACP}" &>/dev/null; then
        log_info "Stopping existing ACP sandbox..." >&2
        stop_sandbox_acp
    fi

    # Set up cleanup trap — must fire on EXIT, INT, TERM, HUP, and PIPE (editor disconnect)
    trap cleanup_acp EXIT INT TERM HUP PIPE

    # Start containers
    log_info "Starting ACP sandbox containers..." >&2
    docker compose -f "$compose_file" -p "$COMPOSE_PROJECT_ACP" up -d --quiet-pull 2>/dev/null

    # Wait for agent container to be ready
    local retries=0
    while ! docker ps -q -f "name=${AGENT_CONTAINER_ACP}" -f "status=running" &>/dev/null && [[ $retries -lt 30 ]]; do
        sleep 0.5
        ((retries++))
    done

    if ! docker ps -q -f "name=${AGENT_CONTAINER_ACP}" -f "status=running" &>/dev/null; then
        log_error "ACP agent container failed to start"
        docker compose -f "$compose_file" -p "$COMPOSE_PROJECT_ACP" logs >&2
        exit 1
    fi

    log_success "ACP sandbox ready — piping stdin/stdout to opencode acp" >&2

    # Create a symlink from the host project path to /workspace inside the container.
    # Editors like Zed send the host path via ACP, and OpenCode uses it as cwd when
    # spawning tools (bash, etc). Without this symlink, posix_spawn fails with ENOENT
    # because the host path doesn't exist inside the container.
    if [[ "$project_dir" != "/workspace" ]]; then
        docker exec -u root "$AGENT_CONTAINER_ACP" bash -c \
            "mkdir -p '$(dirname "$project_dir")' && ln -sfn /workspace '$project_dir'" 2>/dev/null
    fi

    # Start a watchdog that monitors this script's PID. If the process is killed
    # with SIGKILL (which can't be trapped), the watchdog detects the parent is
    # gone and cleans up the containers. This handles Zed force-killing the subprocess.
    # The watchdog must run in its own process session so it survives process group kills.
    local my_pid=$$
    local watchdog_script
    watchdog_script=$(mktemp "${TMPDIR:-/tmp}/opencode-watchdog.XXXXXX")
    cat > "$watchdog_script" << WATCHDOG_EOF
#!/bin/bash
while kill -0 $my_pid 2>/dev/null; do
    sleep 2
done
docker compose -f "$compose_file" -p "$COMPOSE_PROJECT_ACP" down --remove-orphans 2>/dev/null
rm -f "$watchdog_script"
WATCHDOG_EOF
    chmod +x "$watchdog_script"
    # Launch in a new session via perl (setsid not available on macOS)
    perl -e 'use POSIX; fork and exit; POSIX::setsid(); exec @ARGV' "$watchdog_script" &>/dev/null
    WATCHDOG_SCRIPT="$watchdog_script"

    # Run opencode acp inside the container, piping stdin/stdout transparently.
    # Using docker exec -i (no -t) for clean binary-safe stdin/stdout without TTY.
    # Run in background + wait so that signals (HUP, TERM, etc.) interrupt wait
    # and the trap can fire to clean up containers.
    docker exec -i "$AGENT_CONTAINER_ACP" /entrypoint.sh opencode acp --cwd /workspace &
    DOCKER_EXEC_PID=$!
    wait "$DOCKER_EXEC_PID" 2>/dev/null
}

# -----------------------------------------------------------------------------
# Main run function
# -----------------------------------------------------------------------------
run_sandbox() {
    local project_dir="${1:-$(pwd)}"
    local force_build="${FORCE_BUILD:-false}"
    local no_network="${NO_NETWORK:-false}"

    # Resolve to absolute path
    project_dir=$(cd "$project_dir" 2>/dev/null && pwd) || {
        log_error "Directory not found: $project_dir"
        exit 1
    }

    log_header "OpenCode Sandbox"
    echo ""
    log_info "Project: $project_dir"

    # Ensure config exists
    ensure_config

    # Parse config
    parse_config

    # Handle no-network mode
    if [[ "$no_network" == "true" ]]; then
        log_warn "Network access: DISABLED"
        NETWORK_HOSTS=()
    fi

    # Show network whitelist
    if [[ ${#NETWORK_HOSTS[@]} -gt 0 ]]; then
        echo ""
        log_info "Network whitelist:"
        for host in "${NETWORK_HOSTS[@]}"; do
            log_info "  ✓ $host"
        done
    fi

    # Show upstream proxy info if configured
    if [[ -n "$UPSTREAM_PROXY_HOST" ]]; then
        echo ""
        log_info "Upstream proxy: ${UPSTREAM_PROXY_HOST}:${UPSTREAM_PROXY_PORT:-3128}"
        if [[ -n "$NO_PROXY_DOMAINS" ]]; then
            log_info "No proxy: ${NO_PROXY_DOMAINS}"
        fi
    fi

    # Generate config files
    local domains_file
    domains_file=$(generate_allowed_domains)

    local compose_file
    compose_file=$(generate_compose_file "$project_dir" "$domains_file")

    # Build images if needed
    build_images "$force_build" "$compose_file"

    # Stop any existing sandbox
    if docker ps -q -f "name=${AGENT_CONTAINER}" &>/dev/null; then
        log_info "Stopping existing sandbox..."
        stop_sandbox
    fi

    # Set up cleanup trap
    trap cleanup EXIT INT TERM

    # Start containers
    start_sandbox "$compose_file"

    echo ""
    log_success "Sandbox ready!"
    log_info "Press Ctrl+C to exit and stop the sandbox"
    echo ""

    # Attach to agent container
    docker attach "$AGENT_CONTAINER"
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------
main() {
    # Check Docker
    if ! command -v docker &>/dev/null; then
        log_error "Docker not found. Please install Docker Desktop."
        exit 1
    fi

    if ! docker info &>/dev/null 2>&1; then
        log_error "Docker daemon not running. Please start Docker Desktop."
        exit 1
    fi

    # Parse arguments
    local project_dir=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -b|--build)
                export FORCE_BUILD=true
                shift
                ;;
            -u|--update|update)
                update_opencode
                exit 0
                ;;
            -c|--config)
                ensure_config
                ${EDITOR:-vim} "$CONFIG_FILE"
                exit 0
                ;;
            acp)
                shift
                # Collect remaining args for ACP mode (project dir, options)
                local acp_project_dir=""
                while [[ $# -gt 0 ]]; do
                    case "$1" in
                        --no-network) export NO_NETWORK=true; shift ;;
                        --with-ssh)   export WITH_SSH=true; shift ;;
                        -b|--build)   export FORCE_BUILD=true; shift ;;
                        *)            acp_project_dir="$1"; shift ;;
                    esac
                done
                run_sandbox_acp "$acp_project_dir"
                exit 0
                ;;
            build)
                ensure_config
                parse_config
                local domains_file
                domains_file=$(generate_allowed_domains)
                local compose_file
                compose_file=$(generate_compose_file "$(pwd)" "$domains_file")
                build_images "true" "$compose_file"
                exit 0
                ;;
            shell)
                shift
                attach_shell "$@"
                exit 0
                ;;
            stop)
                stop_sandbox
                stop_sandbox_acp 2>/dev/null
                exit 0
                ;;
            --no-network)
                export NO_NETWORK=true
                shift
                ;;
            --with-ssh)
                export WITH_SSH=true
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
            *)
                project_dir="$1"
                shift
                ;;
        esac
    done

    run_sandbox "$project_dir"
}

main "$@"
