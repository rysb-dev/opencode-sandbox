#!/bin/bash
# =============================================================================
# OpenCode Sandbox Launcher
# =============================================================================
# Usage: opencode-sandbox [project-directory]
#
# Runs opencode in a Docker container with:
#   - Network restricted to whitelisted domains via squid proxy
#   - Filesystem restricted to specified directories only
#   - Tool calls require explicit permission
#
# Configuration: ~/.config/opencode-sandbox/config
# =============================================================================

set -e

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/opencode-sandbox"
CONFIG_FILE="$CONFIG_DIR/config"
COMPOSE_PROJECT="opencode-sandbox"
PROXY_CONTAINER="opencode-sandbox-proxy"
AGENT_CONTAINER="opencode-sandbox-agent"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

log_info()    { echo -e "${BLUE}[sandbox]${NC} $1"; }
log_success() { echo -e "${GREEN}[sandbox]${NC} $1"; }
log_warn()    { echo -e "${YELLOW}[sandbox]${NC} $1"; }
log_error()   { echo -e "${RED}[sandbox]${NC} $1" >&2; }
log_header()  { echo -e "${BOLD}$1${NC}"; }

show_help() {
    echo -e "${BOLD}OpenCode Sandbox${NC} - Run opencode in a secure, network-isolated environment"
    echo ""
    echo -e "${BOLD}USAGE:${NC}"
    echo "    opencode-sandbox [OPTIONS] [PROJECT_DIR]"
    echo "    opencode-sandbox shell    Open a bash shell in the running sandbox"
    echo ""
    echo -e "${BOLD}ARGUMENTS:${NC}"
    echo "    PROJECT_DIR    Directory to mount as workspace (default: current directory)"
    echo ""
    echo -e "${BOLD}COMMANDS:${NC}"
    echo "    shell          Open a bash shell in the running sandbox container"
    echo "    stop           Stop all sandbox containers"
    echo "    update         Update opencode to the latest version (rebuilds image)"
    echo ""
    echo -e "${BOLD}OPTIONS:${NC}"
    echo "    -h, --help     Show this help message"
    echo "    -b, --build    Force rebuild of Docker images"
    echo "    -u, --update   Update opencode to latest version (same as 'update')"
    echo "    -c, --config   Open configuration file in editor"
    echo "    --no-network   Disable all network access"
    echo ""
    echo -e "${BOLD}CONFIGURATION:${NC}"
    echo "    Edit: $CONFIG_FILE"
    echo ""
    echo "    Network whitelist: Add domains (one per line) under [network]"
    echo "    Filesystem mounts: Add paths under [filesystem]"
    echo ""
    echo -e "${BOLD}EXAMPLES:${NC}"
    echo "    opencode-sandbox                    # Run in current directory"
    echo "    opencode-sandbox ~/Projects/myapp   # Run in specific directory"
    echo "    opencode-sandbox shell              # Open shell in running sandbox"
    echo "    opencode-sandbox stop               # Stop all sandbox containers"
    echo "    opencode-sandbox update             # Update opencode to latest"
    echo "    opencode-sandbox --build            # Rebuild images and run"
    echo ""
}

# -----------------------------------------------------------------------------
# Ensure config directory and files exist
# -----------------------------------------------------------------------------
ensure_config() {
    if [[ ! -d "$CONFIG_DIR" ]]; then
        log_info "Creating configuration directory: $CONFIG_DIR"
        mkdir -p "$CONFIG_DIR"
    fi

    if [[ ! -f "$CONFIG_FILE" ]]; then
        log_info "Creating default configuration file"
        cat > "$CONFIG_FILE" << 'CONFIGEOF'
# =============================================================================
# OpenCode Sandbox Configuration
# =============================================================================
# Network whitelist: Domains opencode can connect to (one per line)
# Filesystem mounts: Additional directories to mount (one per line)
# =============================================================================

[network]
# LLM API providers (leading dot matches subdomains)
.anthropic.com
.openai.com

# GitHub - narrowed to specific subdomains for git operations
github.com
api.github.com
codeload.github.com
raw.githubusercontent.com
objects.githubusercontent.com

# GitHub Copilot
copilot-proxy.githubusercontent.com
origin-tracker.githubusercontent.com
.githubcopilot.com

# GitLab (uncomment if needed)
# gitlab.com
# .gitlab.com

# Python / pip / PyPI
pypi.org
files.pythonhosted.org

# Rust / Cargo / crates.io
crates.io
static.crates.io
index.crates.io

# Add additional domains below (use leading dot for subdomains):
# .example.com      - matches example.com and *.example.com
# api.example.com   - matches only api.example.com


[proxy]
# Corporate/upstream proxy configuration (optional)
# If your network requires a proxy to reach the internet, configure it here.
# The sandbox's squid proxy will route traffic through your corporate proxy.
#
# http_proxy=http://proxy.company.com:8080
# https_proxy=http://proxy.company.com:8080
# no_proxy=localhost,127.0.0.1,.internal.company.com,intranet.local
#
# Note: no_proxy domains will be accessed directly, bypassing the upstream proxy.
# This is useful for internal/intranet hosts that don't need the corporate proxy.


[filesystem]
# Additional directories to mount (read-only by default)
# Format:
#   /path/to/directory        - mounted read-only
#   /path/to/directory:rw     - mounted read-write
#
# Example:
#   /Users/yourname/shared-libs
#   /Users/yourname/other-project:rw


[environment]
# Additional environment variables for the agent container
# Format: KEY=value
#
# Example:
#   NODE_EXTRA_CA_CERTS=/mnt/certs/mycerts.pem

CONFIGEOF
    fi
}

# -----------------------------------------------------------------------------
# Parse configuration file
# -----------------------------------------------------------------------------
parse_config() {
    NETWORK_HOSTS=()
    FILESYSTEM_MOUNTS=()
    AGENT_ENV_VARS=()
    UPSTREAM_PROXY_HOST=""
    UPSTREAM_PROXY_PORT=""
    NO_PROXY_DOMAINS=""

    if [[ ! -f "$CONFIG_FILE" ]]; then
        log_warn "Config file not found: $CONFIG_FILE"
        return
    fi

    local section=""
    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines and comments
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        line=$(echo "$line" | xargs)  # trim whitespace

        # Check for section headers
        if [[ "$line" =~ ^\[.*\]$ ]]; then
            section=""
            [[ "$line" == *"network"* || "$line" == *"NETWORK"* ]] && section="network"
            [[ "$line" == *"filesystem"* || "$line" == *"FILESYSTEM"* ]] && section="filesystem"
            [[ "$line" == *"proxy"* || "$line" == *"PROXY"* ]] && section="proxy"
            [[ "$line" == *"environment"* || "$line" == *"ENVIRONMENT"* ]] && section="environment"
            continue
        fi

        case "$section" in
            network)    NETWORK_HOSTS+=("$line") ;;
            filesystem) FILESYSTEM_MOUNTS+=("$line") ;;
            environment)
                # Parse KEY=value pairs for environment variables
                if [[ "$line" =~ ^[A-Za-z_][A-Za-z0-9_]*= ]]; then
                    AGENT_ENV_VARS+=("$line")
                fi
                ;;
            proxy)
                # Parse key=value pairs for proxy settings
                if [[ "$line" =~ ^http_proxy[[:space:]]*= ]]; then
                    local proxy_url="${line#*=}"
                    proxy_url=$(echo "$proxy_url" | xargs)  # trim whitespace
                    # Parse host:port from URL (http://host:port or host:port)
                    proxy_url="${proxy_url#http://}"
                    proxy_url="${proxy_url#https://}"
                    UPSTREAM_PROXY_HOST="${proxy_url%%:*}"
                    UPSTREAM_PROXY_PORT="${proxy_url##*:}"
                    # If no port specified, default to 3128
                    [[ "$UPSTREAM_PROXY_HOST" == "$UPSTREAM_PROXY_PORT" ]] && UPSTREAM_PROXY_PORT="3128"
                elif [[ "$line" =~ ^https_proxy[[:space:]]*= ]]; then
                    # Only use https_proxy if http_proxy not already set
                    if [[ -z "$UPSTREAM_PROXY_HOST" ]]; then
                        local proxy_url="${line#*=}"
                        proxy_url=$(echo "$proxy_url" | xargs)
                        proxy_url="${proxy_url#http://}"
                        proxy_url="${proxy_url#https://}"
                        UPSTREAM_PROXY_HOST="${proxy_url%%:*}"
                        UPSTREAM_PROXY_PORT="${proxy_url##*:}"
                        [[ "$UPSTREAM_PROXY_HOST" == "$UPSTREAM_PROXY_PORT" ]] && UPSTREAM_PROXY_PORT="3128"
                    fi
                elif [[ "$line" =~ ^no_proxy[[:space:]]*= ]]; then
                    NO_PROXY_DOMAINS="${line#*=}"
                    NO_PROXY_DOMAINS=$(echo "$NO_PROXY_DOMAINS" | xargs)
                fi
                ;;
        esac
    done < "$CONFIG_FILE"
}

# -----------------------------------------------------------------------------
# Generate allowed_domains.txt for squid proxy
# -----------------------------------------------------------------------------
generate_allowed_domains() {
    local domains_file="$CONFIG_DIR/allowed_domains.txt"

    cat > "$domains_file" << 'EOF'
# Auto-generated from config - do not edit directly
# Edit ~/.config/opencode-sandbox/config instead
EOF

    for host in "${NETWORK_HOSTS[@]}"; do
        echo "$host" >> "$domains_file"
    done

    echo "$domains_file"
}

# -----------------------------------------------------------------------------
# Generate docker-compose.yml
# -----------------------------------------------------------------------------
generate_compose_file() {
    local project_dir="$1"
    local domains_file="$2"
    local compose_file="$CONFIG_DIR/docker-compose.yml"

    # Get host UID/GID for proper file permission mapping
    local host_uid=$(id -u)
    local host_gid=$(id -g)

    # Build volume mounts for agent
    local volume_mounts=""
    volume_mounts+="      - ${project_dir}:/workspace:rw"$'\n'

    # OpenCode config directories
    local opencode_config="$HOME/.config/opencode"
    local opencode_cache="$HOME/.cache/opencode"
    local opencode_data="$HOME/.local/share/opencode"
    local opencode_state="$HOME/.local/state/opencode"

    # Create directories if they don't exist
    mkdir -p "$opencode_cache" "$opencode_data" "$opencode_state"

    # Mount opencode directories
    if [[ -d "$opencode_config" ]]; then
        volume_mounts+="      - ${opencode_config}:/home/coder/.config/opencode:rw"$'\n'
    fi
    volume_mounts+="      - ${opencode_cache}:/home/coder/.cache/opencode:rw"$'\n'
    volume_mounts+="      - ${opencode_data}:/home/coder/.local/share/opencode:rw"$'\n'
    volume_mounts+="      - ${opencode_state}:/home/coder/.local/state/opencode:rw"$'\n'

    # Git config (read-write so git can add safe.directory)
    [[ -f "$HOME/.gitconfig" ]] && volume_mounts+="      - ${HOME}/.gitconfig:/home/coder/.gitconfig:rw"$'\n'
    [[ -d "$HOME/.config/git" ]] && volume_mounts+="      - ${HOME}/.config/git:/home/coder/.config/git:ro"$'\n'

    # SSH keys (mounted read-only, entrypoint copies with correct permissions)
    [[ -d "$HOME/.ssh" ]] && volume_mounts+="      - ${HOME}/.ssh:/mnt/ssh:ro"$'\n'

    # Additional filesystem mounts from config
    for mount in "${FILESYSTEM_MOUNTS[@]}"; do
        local host_path="${mount%%:*}"
        local mode="ro"
        [[ "$mount" == *":rw" ]] && mode="rw"
        host_path="${host_path%:rw}"

        if [[ -d "$host_path" ]]; then
            local container_path="/mnt$(echo "$host_path" | tr ' ' '_')"
            volume_mounts+="      - ${host_path}:${container_path}:${mode}"$'\n'
        fi
    done

    # Build proxy environment variables for upstream proxy
    local proxy_env=""
    if [[ -n "$UPSTREAM_PROXY_HOST" ]]; then
        proxy_env+="    environment:"$'\n'
        proxy_env+="      - UPSTREAM_PROXY_HOST=${UPSTREAM_PROXY_HOST}"$'\n'
        proxy_env+="      - UPSTREAM_PROXY_PORT=${UPSTREAM_PROXY_PORT:-3128}"$'\n'
        if [[ -n "$NO_PROXY_DOMAINS" ]]; then
            proxy_env+="      - NO_PROXY_DOMAINS=${NO_PROXY_DOMAINS}"$'\n'
        fi
    fi

    cat > "$compose_file" << EOF
# Auto-generated - do not edit directly
services:
  proxy:
    build:
      context: ${SCRIPT_DIR}/proxy
    container_name: ${PROXY_CONTAINER}
    networks:
      - external
      - internal
    volumes:
      - ${domains_file}:/etc/squid/allowed_domains.txt:ro
${proxy_env}    healthcheck:
      test: ["CMD-SHELL", "nc -z localhost 3128 || exit 1"]
      interval: 3s
      timeout: 2s
      retries: 5
      start_period: 2s

  agent:
    build:
      context: ${SCRIPT_DIR}/agent
      args:
        - USER_UID=${host_uid}
        - USER_GID=${host_gid}
    container_name: ${AGENT_CONTAINER}
    stdin_open: true
    tty: true
    networks:
      - internal
    depends_on:
      proxy:
        condition: service_healthy
    environment:
      - HTTP_PROXY=http://proxy:3128
      - HTTPS_PROXY=http://proxy:3128
      - http_proxy=http://proxy:3128
      - https_proxy=http://proxy:3128
      - NO_PROXY=localhost,127.0.0.1
      - no_proxy=localhost,127.0.0.1
      - TERM=${TERM:-xterm-256color}
$(for env_var in "${AGENT_ENV_VARS[@]}"; do echo "      - ${env_var}"; done)
    volumes:
${volume_mounts}    working_dir: /workspace

networks:
  external:
    driver: bridge
  internal:
    driver: bridge
    internal: true
EOF

    echo "$compose_file"
}

# -----------------------------------------------------------------------------
# Build Docker images
# -----------------------------------------------------------------------------
build_images() {
    local force="${1:-false}"
    local compose_file="$2"
    local no_cache="${3:-false}"

    # Check if images exist
    local need_build=false
    if [[ "$force" == "true" ]]; then
        need_build=true
    elif ! docker image inspect "${COMPOSE_PROJECT}-proxy" &>/dev/null || \
         ! docker image inspect "${COMPOSE_PROJECT}-agent" &>/dev/null; then
        need_build=true
    fi

    if [[ "$need_build" == "true" ]]; then
        log_info "Building Docker images..."
        if [[ "$no_cache" == "true" ]]; then
            docker compose -f "$compose_file" -p "$COMPOSE_PROJECT" build --no-cache --quiet
        else
            docker compose -f "$compose_file" -p "$COMPOSE_PROJECT" build --quiet
        fi
        log_success "Images built successfully"
    fi
}

# -----------------------------------------------------------------------------
# Update opencode (rebuild with no cache)
# -----------------------------------------------------------------------------
update_opencode() {
    log_header "Updating OpenCode"
    echo ""

    # Ensure config exists
    ensure_config

    # Parse config
    parse_config

    # Generate config files
    local domains_file
    domains_file=$(generate_allowed_domains)

    local compose_file
    compose_file=$(generate_compose_file "$(pwd)" "$domains_file")

    log_info "Rebuilding agent image with latest opencode..."
    docker compose -f "$compose_file" -p "$COMPOSE_PROJECT" build --no-cache agent

    echo ""
    log_success "Update complete!"

    # Show new version
    local version
    version=$(docker run --rm "${COMPOSE_PROJECT}-agent" opencode --version 2>/dev/null || echo "unknown")
    log_info "OpenCode version: $version"
}

# -----------------------------------------------------------------------------
# Start sandbox containers
# -----------------------------------------------------------------------------
start_sandbox() {
    local compose_file="$1"

    log_info "Starting sandbox containers..."
    docker compose -f "$compose_file" -p "$COMPOSE_PROJECT" up -d --quiet-pull 2>/dev/null

    # Wait for agent to be ready
    local retries=0
    while ! docker ps -q -f "name=${AGENT_CONTAINER}" -f "status=running" &>/dev/null && [[ $retries -lt 30 ]]; do
        sleep 0.5
        ((retries++))
    done

    if ! docker ps -q -f "name=${AGENT_CONTAINER}" -f "status=running" &>/dev/null; then
        log_error "Agent container failed to start"
        docker compose -f "$compose_file" -p "$COMPOSE_PROJECT" logs
        exit 1
    fi
}

# -----------------------------------------------------------------------------
# Stop sandbox containers
# -----------------------------------------------------------------------------
stop_sandbox() {
    local compose_file="$CONFIG_DIR/docker-compose.yml"

    if [[ -f "$compose_file" ]]; then
        log_info "Stopping sandbox containers..."
        docker compose -f "$compose_file" -p "$COMPOSE_PROJECT" down --remove-orphans 2>/dev/null || true
    else
        # Fallback: stop by container name
        docker stop "$AGENT_CONTAINER" "$PROXY_CONTAINER" 2>/dev/null || true
        docker rm "$AGENT_CONTAINER" "$PROXY_CONTAINER" 2>/dev/null || true
    fi
    log_success "Sandbox stopped"
}

# -----------------------------------------------------------------------------
# Attach to running sandbox
# -----------------------------------------------------------------------------
attach_shell() {
    if ! docker ps -q -f "name=${AGENT_CONTAINER}" -f "status=running" &>/dev/null; then
        log_error "No running sandbox found."
        echo ""
        echo "Start a sandbox first with:"
        echo "  opencode-sandbox [project-directory]"
        exit 1
    fi

    log_info "Attaching shell to running sandbox..."
    log_info "Type 'exit' to close this shell (sandbox will keep running)"
    echo ""

    docker exec -it "$AGENT_CONTAINER" bash
}

# -----------------------------------------------------------------------------
# Cleanup on exit
# -----------------------------------------------------------------------------
cleanup() {
    echo ""
    log_info "Shutting down sandbox..."
    stop_sandbox
}

# -----------------------------------------------------------------------------
# Main run function
# -----------------------------------------------------------------------------
run_sandbox() {
    local project_dir="${1:-$(pwd)}"
    local force_build="${FORCE_BUILD:-false}"
    local no_network="${NO_NETWORK:-false}"

    # Resolve to absolute path
    project_dir=$(cd "$project_dir" 2>/dev/null && pwd) || {
        log_error "Directory not found: $project_dir"
        exit 1
    }

    log_header "OpenCode Sandbox"
    echo ""
    log_info "Project: $project_dir"

    # Ensure config exists
    ensure_config

    # Parse config
    parse_config

    # Handle no-network mode
    if [[ "$no_network" == "true" ]]; then
        log_warn "Network access: DISABLED"
        NETWORK_HOSTS=()
    fi

    # Show network whitelist
    if [[ ${#NETWORK_HOSTS[@]} -gt 0 ]]; then
        echo ""
        log_info "Network whitelist:"
        for host in "${NETWORK_HOSTS[@]}"; do
            log_info "  âœ“ $host"
        done
    fi

    # Show upstream proxy info if configured
    if [[ -n "$UPSTREAM_PROXY_HOST" ]]; then
        echo ""
        log_info "Upstream proxy: ${UPSTREAM_PROXY_HOST}:${UPSTREAM_PROXY_PORT:-3128}"
        if [[ -n "$NO_PROXY_DOMAINS" ]]; then
            log_info "No proxy: ${NO_PROXY_DOMAINS}"
        fi
    fi

    # Generate config files
    local domains_file
    domains_file=$(generate_allowed_domains)

    local compose_file
    compose_file=$(generate_compose_file "$project_dir" "$domains_file")

    # Build images if needed
    build_images "$force_build" "$compose_file"

    # Stop any existing sandbox
    if docker ps -q -f "name=${AGENT_CONTAINER}" &>/dev/null; then
        log_info "Stopping existing sandbox..."
        stop_sandbox
    fi

    # Set up cleanup trap
    trap cleanup EXIT INT TERM

    # Start containers
    start_sandbox "$compose_file"

    echo ""
    log_success "Sandbox ready!"
    log_info "Press Ctrl+C to exit and stop the sandbox"
    echo ""

    # Attach to agent container
    docker attach "$AGENT_CONTAINER"
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------
main() {
    # Check Docker
    if ! command -v docker &>/dev/null; then
        log_error "Docker not found. Please install Docker Desktop."
        exit 1
    fi

    if ! docker info &>/dev/null 2>&1; then
        log_error "Docker daemon not running. Please start Docker Desktop."
        exit 1
    fi

    # Parse arguments
    local project_dir=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -b|--build)
                export FORCE_BUILD=true
                shift
                ;;
            -u|--update|update)
                update_opencode
                exit 0
                ;;
            -c|--config)
                ensure_config
                ${EDITOR:-vim} "$CONFIG_FILE"
                exit 0
                ;;
            shell)
                attach_shell
                exit 0
                ;;
            stop)
                stop_sandbox
                exit 0
                ;;
            --no-network)
                export NO_NETWORK=true
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
            *)
                project_dir="$1"
                shift
                ;;
        esac
    done

    run_sandbox "$project_dir"
}

main "$@"
